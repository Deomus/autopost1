import asyncio, uuid, os
from aiogram import F, Router
from aiogram.types import Message
from aiogram.fsm.context import FSMContext

from states import States
from database import MongoDB
from loguru import logger

from keyboards import settings_keyboard
import yt_dlp

router = Router()


@router.message(F.text.startswith('https://www.instagram.com/reel/'))
async def video_url(message: Message, state: FSMContext):
    try:
        sent_msg = await message.answer("Загрузка видео...")

        user = await MongoDB().get_user(message.from_user.id)
        if not user or not user.account_insta or not user.account_insta.cookies:
            await sent_msg.edit_text("У вас нет сохранённых куков Instagram")
            return

        cookies = user.account_insta.cookies

        filepath = f"./downloads/{uuid.uuid4()}.mp4"
        cookies_file = f"./cookies_{message.from_user.id}.txt"

        # Создаём Netscape cookie файл
        with open(cookies_file, "w", encoding="utf-8") as f:
            # Шапка (обязательно, иначе yt-dlp может ругаться)
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# This file is generated by our bot. Do not edit.\n\n")

            for cookie in cookies:
                # Пропускаем куки, у которых expires = -1
                if cookie.get('expires', 0) < 0:
                    continue

                # Преобразуем expires в целое
                expires = int(cookie.get('expires', 0))

                domain = cookie['domain'].lstrip('.')  # убираем ведущую точку
                path = cookie.get('path', '/')
                secure_flag = "TRUE" if cookie.get('secure', False) else "FALSE"
                http_only_flag = "FALSE"  # Netscape формат не хранит признак httpOnly, можно игнорировать
                name = cookie['name']
                value = cookie['value']

                # Пишем строку:
                # domain <TAB> httpOnlyOrNot <TAB> path <TAB> secureFlag <TAB> expires <TAB> name <TAB> value
                #   * httpOnlyOrNot = TRUE or FALSE
                # В старых спецификациях иногда используют 2-й столбец как “domain_flag”.
                # yt-dlp обычно ожидает:
                #   domain, (TRUE|FALSE), path, (TRUE|FALSE), expiry, name, value
                f.write(
                    f"{domain}\t"           # domain
                    f"FALSE\t"              # domain-flag (если начинается с точек - TRUE, но мы убираем точку)
                    f"{path}\t"
                    f"{secure_flag}\t"
                    f"{expires}\t"
                    f"{name}\t"
                    f"{value}\n"
                )

        # Настройки yt-dlp
        ydl_opts = {
            'outtmpl': filepath,
            'quiet': True,
            'no_warnings': True,
            'format': 'best[ext=mp4]/best',
            'cookiefile': cookies_file,
        }

        import yt_dlp
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([message.text])

        # Удаляем временный файл куков
        os.remove(cookies_file)

        if os.path.exists(filepath):
            await MongoDB().add_to_queue(message.from_user.id, filepath)
            await sent_msg.edit_text(f"Видео скачано и добавлено в очередь\n{message.text}")
        else:
            raise Exception("Видео не скачалось или не найдено.")

    except Exception as e:
        logger.error(f"Ошибка при загрузке reels: {e}")
        await sent_msg.edit_text(f"Ошибка в загрузке видео\n{message.text}")
